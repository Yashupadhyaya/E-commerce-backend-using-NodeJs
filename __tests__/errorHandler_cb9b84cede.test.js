// ********RoostGPT********
/*
Test generated by RoostGPT for test nodejs-test-vscode1 using AI Type  and AI Model 

ROOST_METHOD_HASH=errorHandler_565ec721bb
ROOST_METHOD_SIG_HASH=errorHandler_cb9b84cede


*/

// ********RoostGPT********
// Importing necessary packages and modules
const httpMocks = require('node-mocks-http');
const errorHandler = require('../helpers/error-handler');

describe('Error Handler Middleware', () => {
    let mockRequest, mockResponse, mockNext;

    beforeEach(() => {
        mockRequest = httpMocks.createRequest();
        mockResponse = httpMocks.createResponse();
        mockNext = jest.fn();
    });

    test('should return 401 status if error name is UnauthorizedError', () => {
        const error = new Error('Unauthorized');
        error.name = 'UnauthorizedError';
        errorHandler(error, mockRequest, mockResponse, mockNext);
        expect(mockResponse.statusCode).toBe(401);
        expect(mockResponse._getJSONData()).toEqual({ message: 'The user is not authorized' });
    });

    test('should return 401 status if error name is ValidationError', () => {
        const error = new Error('Validation failed');
        error.name = 'ValidationError';
        errorHandler(error, mockRequest, mockResponse, mockNext);
        expect(mockResponse.statusCode).toBe(401);
        expect(mockResponse._getJSONData()).toEqual({ message: error });
    });

    test('should return 500 status for any other error', () => {
        const error = new Error('Server error');
        errorHandler(error, mockRequest, mockResponse, mockNext);
        expect(mockResponse.statusCode).toBe(500);
        expect(mockResponse._getJSONData()).toEqual(error);
    });

    test('should call next function if no error', () => {
        errorHandler(null, mockRequest, mockResponse, mockNext);
        expect(mockNext).toHaveBeenCalled();
    });
});
